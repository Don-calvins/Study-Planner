<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Planner Web App</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        input, textarea { width: 100%; padding: 10px; margin: 10px 0; }
        button { background: #4CAF50; color: white; padding: 12px; border: none; cursor: pointer; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>Study Planner from Document</h1>
    <input type="file" id="fileInput" accept=".txt,.pdf" />
    <textarea id="content" placeholder="Paste document text here (or upload file)" rows="10"></textarea>
    <button onclick="generatePlan()">Generate Plan</button>
    <div id="planOutput"></div>

    <script>
       <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2"></script>
<script>
    let pipe = null;
    
    async function initAI() {
        if (!pipe) {
            pipe = await Xenova.pipeline('token-classification', 'Xenova/bert-base-NER');
        }
    }
    
    document.getElementById('fileInput').addEventListener('change', handleFile);
    
    async function handleFile(e) {
        await initAI();
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                document.getElementById('content').value = text;
                // Auto-generate on upload
                await generatePlan();
            };
            reader.readAsText(file);
        }
    }
    
    async function generatePlan() {
        await initAI();
        const text = document.getElementById('content').value;
        const topics = await extractTopicsAI(text);
        const plan = createOptimizedPlan(topics);
        document.getElementById('planOutput').innerHTML = renderTable(plan);
    }
    
    async function extractTopicsAI(text) {
        // AI extracts entities (topics, dates, subjects)
        const result = await pipe(text);
        const topics = new Set();
        result.forEach(ent => {
            if (ent.entity_group === 'MISC' || ent.score > 0.5) {
                topics.add(ent.word);
            }
        });
        
        // Fallback + smart parsing for chapters/deadlines
        const lines = text.toLowerCase().split('\n');
        lines.forEach(line => {
            if (line.match(/(chapter|topic|unit|module)[\s\w.-]+/i)) {
                topics.add(line.match(/(chapter|topic|unit|module)[\s\w.-]{1,20}/i)[0]);
            }
            if (line.match(/due|exam|test\s+\w+/i)) {
                topics.add(line.match(/due|exam|test\s+\w+/i)[0]);
            }
        });
        
        return Array.from(topics).slice(0, 12) || ['Algebra Basics', 'Physics Mechanics', 'History 20th Century'];
    }
    
    function createOptimizedPlan(topics) {
        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const plan = { headers: ['Time Slot', ...days, 'Sun'], rows: [] };
        
        // AI-style optimization: distribute by estimated difficulty, add spaced repetition
        const slots = [
            { time: '7-9 AM (Focus)', priority: 'hard' },
            { time: '4-6 PM (Review)', priority: 'medium' },
            { time: '8-9 PM (Light)', priority: 'easy' }
        ];
        
        let topicIndex = 0;
        slots.forEach(slot => {
            const row = { time: slot.time, tasks: {} };
            for (let day of days) {
                if (topicIndex < topics.length) {
                    row.tasks[day] = topics[topicIndex++ % topics.length];
                } else {
                    row.tasks[day] = 'Spaced Review';
                }
            }
            row.tasks['Sun'] = 'Weekly Review + Weak Areas';
            plan.rows.push(row);
        });
        return plan;
    }
    
    // renderTable function stays the same as before
    function renderTable(plan) {
        let html = '<table><tr><th>' + plan.headers.join('</th><th>') + '</th></tr>';
        plan.rows.forEach(row => {
            html += '<tr><td>' + row.time + '</td>';
            plan.headers.slice(1).forEach(day => {
                html += '<td>' + (row.tasks[day] || 'Rest/Break') + '</td>';
            });
            html += '</tr>';
        });
        html += '</table>';
        return html;
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2"></script>
<script>
    let pipe = null;
    
    async function initAI() {
        if (!pipe) {
            pipe = await Xenova.pipeline('token-classification', 'Xenova/bert-base-NER');
        }
    }
    
    document.getElementById('fileInput').addEventListener('change', handleFile);
    
    async function handleFile(e) {
        await initAI();
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                document.getElementById('content').value = text;
                // Auto-generate on upload
                await generatePlan();
            };
            reader.readAsText(file);
        }
    }
    
    async function generatePlan() {
        await initAI();
        const text = document.getElementById('content').value;
        const topics = await extractTopicsAI(text);
        const plan = createOptimizedPlan(topics);
        document.getElementById('planOutput').innerHTML = renderTable(plan);
    }
    
    async function extractTopicsAI(text) {
        // AI extracts entities (topics, dates, subjects)
        const result = await pipe(text);
        const topics = new Set();
        result.forEach(ent => {
            if (ent.entity_group === 'MISC' || ent.score > 0.5) {
                topics.add(ent.word);
            }
        });
        
        // Fallback + smart parsing for chapters/deadlines
        const lines = text.toLowerCase().split('\n');
        lines.forEach(line => {
            if (line.match(/(chapter|topic|unit|module)[\s\w.-]+/i)) {
                topics.add(line.match(/(chapter|topic|unit|module)[\s\w.-]{1,20}/i)[0]);
            }
            if (line.match(/due|exam|test\s+\w+/i)) {
                topics.add(line.match(/due|exam|test\s+\w+/i)[0]);
            }
        });
        
        return Array.from(topics).slice(0, 12) || ['Algebra Basics', 'Physics Mechanics', 'History 20th Century'];
    }
    
    function createOptimizedPlan(topics) {
        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const plan = { headers: ['Time Slot', ...days, 'Sun'], rows: [] };
        
        // AI-style optimization: distribute by estimated difficulty, add spaced repetition
        const slots = [
            { time: '7-9 AM (Focus)', priority: 'hard' },
            { time: '4-6 PM (Review)', priority: 'medium' },
            { time: '8-9 PM (Light)', priority: 'easy' }
        ];
        
        let topicIndex = 0;
        slots.forEach(slot => {
            const row = { time: slot.time, tasks: {} };
            for (let day of days) {
                if (topicIndex < topics.length) {
                    row.tasks[day] = topics[topicIndex++ % topics.length];
                } else {
                    row.tasks[day] = 'Spaced Review';
                }
            }
            row.tasks['Sun'] = 'Weekly Review + Weak Areas';
            plan.rows.push(row);
        });
        return plan;
    }
    
    // renderTable function stays the same as before
    function renderTable(plan) {
        let html = '<table><tr><th>' + plan.headers.join('</th><th>') + '</th></tr>';
        plan.rows.forEach(row => {
            html += '<tr><td>' + row.time + '</td>';
            plan.headers.slice(1).forEach(day => {
                html += '<td>' + (row.tasks[day] || 'Rest/Break') + '</td>';
            });
            html += '</tr>';
        });
        html += '</table>';
        return html;
    }
</script>

    </script>
</body>
</html>
